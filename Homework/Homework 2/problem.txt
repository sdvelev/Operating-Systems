Вашата задача ще е да имплементирате виртуална машина с памет с произволен
достъп.

Виртуалната машина ще бъде извиквана по следния начин:

    ./main program.orc

Където program.orc е файл във формат ORC (измислен за целите на тази задача),
съдържащ "машинният код" - програмата, която вашата виртуална машина трябва да
изпълни. В директория examples/ имате няколко примерни програми.

Една програма има следната структура:

- (char[3])  - магическата дума "ORC"
- (uint32_t) - числото ram_size, което посочва колко клетки памет трябва да има
               на разположение машината, докато изпълнява програмата (*1)
- останалата част от програмата е последователност от инструкции.

Всяка инструкция има размер 25 байта. Първият байт на всяка инструкция е
нейният opcode (число, което третираме като "номер" на инструкцията в таблицата
по-долу), а останалите 24 байта са операнди на инструкцията. Всички операнди са
от тип int64_t, а ако инструкцията използва по-малко от 3 операнда,
неизползваните се игнорират.

Програмата оперира върху памет с размер ram_size на брой клетки, като всяка
клетка е от тип int64_t. Клетките са номерирани, и казваме, че имат "адреси":
първата клетка е с адрес 0, втората с адрес 1 и т.н.

Ето таблица с всички възможни инструкции (колонката "име" е само информативна и
не е пряко свързана с решението):

opcode  име     операнди        описание
================================================================================
0x00    nop                     не прави нищо

0x95    set     tar, val        записваме стойността val в клетка с адрес tar

0x5d    load    to, from_ptr    копираме стойността от клетката с адрес
                                стойността в клетката from_ptr в
                                клетката с адрес to

0x63    store   to_ptr, from    копираме стойността от клетката с адрес
                                from в клетката с адрес стойността на клетката
                                to_ptr

0x91    jmp     idx             скачаме на инструкция с адрес стойността
                                на клетката с адрес idx и
                                продължаваме изпълнението от там
                                (първата инструкция в програмата е с номер 0
                                и т.н.)

0x25    sgz      v              ако стойността на клетката с адрес v е > 0,
                                пропускаме следващата инструкция

0xAD    add     res, v1, v2     в клетката с адрес res записваме сбора на
                                числата в клетките с адреси v1 и v2

0x33    mul     res, v1, v2     в клетката с адрес res записваме произведението
                                на числата в клетките с адреси v1 и v2

0x04    div     res, v1, v2     в клетката с адрес res записваме частното
                                на числата в клетките с адреси v1 и v2
                                (*2)

0xB5    mod     res, v1, v2     в клетката с адрес res записваме остатъка
                                на числата в клетките с адреси v1 и v2
                                (*2)

0xC1    out     v               на stdout извеждаме символа с ascii код числото
                                в клетката с адрес v

0xBF    sleep   v               блокираме изпълнението за толкова милисекунди,
                                колкото е числото в клетката с адрес v
================================================================================

Виртуалналната машина изпълнява инструкциите, започвайки от първата инструкция
в програмата, и след всяка инструкция (освен jmp) преминава на следващата.

Когато изпълним последната инструкция от програмата, виртуалната машина
приключва изпълнението си успешно. Ако по време на изпълнение се е случила
грешка, виртуалната машина приключва с неуспех. Възможни грешки са "невалиден
адрес", "деление на 0", "невалидна инструкция", и др.

За компилиране на вашата програма е предоставен Makefile. Програмата ви трябва
да се компилира успешно с въпросния Makefile.

(*1) - това означава, че можем да алокираме цялата памет в началото, което е
       за улеснение.
(*2) - дели се на стойността на клетката с адрес v2.
